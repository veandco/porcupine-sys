#![allow(dead_code, non_upper_case_globals, non_camel_case_types, non_snake_case)]

/* automatically generated by rust-bindgen */

extern "C" {
    #[doc = " Audio sample rate accepted by Picovoice."]
    pub fn pv_sample_rate() -> ::std::os::raw::c_int;
}
pub const pv_status_t_PV_STATUS_SUCCESS: pv_status_t = 0;
pub const pv_status_t_PV_STATUS_OUT_OF_MEMORY: pv_status_t = 1;
pub const pv_status_t_PV_STATUS_IO_ERROR: pv_status_t = 2;
pub const pv_status_t_PV_STATUS_INVALID_ARGUMENT: pv_status_t = 3;
pub const pv_status_t_PV_STATUS_STOP_ITERATION: pv_status_t = 4;
pub const pv_status_t_PV_STATUS_KEY_ERROR: pv_status_t = 5;
pub const pv_status_t_PV_STATUS_INVALID_STATE: pv_status_t = 6;
#[doc = " Status codes."]
pub type pv_status_t = u32;
extern "C" {
    #[doc = " Provides string representations of status codes."]
    #[doc = ""]
    #[doc = " @param status Status code."]
    #[doc = " @return String representation."]
    pub fn pv_status_to_string(status: pv_status_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_porcupine {
    _unused: [u8; 0],
}
#[doc = " Forward declaration for keyword spotting class (Porcupine). It detects utterances of given keywords within an"]
#[doc = " incoming stream of audio in real-time. It processes incoming audio in consecutive frames and for each frame emits the"]
#[doc = " detection result. The number of samples per frame can be attained by calling 'pv_porcupine_frame_length()'. The"]
#[doc = " incoming audio needs to have a sample rate equal to 'pv_sample_rate()' and be 16-bit linearly-encoded. Porcupine"]
#[doc = " operates on single-channel audio."]
pub type pv_porcupine_t = pv_porcupine;
extern "C" {
    #[doc = " Constructor."]
    #[doc = ""]
    #[doc = " @param model_path Absolute path to the file containing model parameters."]
    #[doc = " @param num_keywords Number of keywords to monitor."]
    #[doc = " @param keyword_paths Absolute paths to keyword model files."]
    #[doc = " @param sensitivities Sensitivities for detecting keywords. Each value should be a number within [0, 1]. A higher"]
    #[doc = " sensitivity results in fewer misses at the cost of increasing the false alarm rate."]
    #[doc = " @param[out] object Constructed keyword spotting object."]
    #[doc = " @return Status code. Returns 'PV_STATUS_INVALID_ARGUMENT', 'PV_STATUS_IO_ERROR', or 'PV_STATUS_OUT_OF_MEMORY' on"]
    #[doc = " failure."]
    pub fn pv_porcupine_init(
        model_path: *const ::std::os::raw::c_char,
        num_keywords: i32,
        keyword_paths: *const *const ::std::os::raw::c_char,
        sensitivities: *const f32,
        object: *mut *mut pv_porcupine_t,
    ) -> pv_status_t;
}
extern "C" {
    #[doc = " Destructor."]
    #[doc = ""]
    #[doc = " @param object Keyword spotting object."]
    pub fn pv_porcupine_delete(object: *mut pv_porcupine_t);
}
extern "C" {
    #[doc = " Processes a frame of the incoming audio stream and emits the detection result."]
    #[doc = ""]
    #[doc = " @param object Keyword spotting object."]
    #[doc = " @param pcm A frame of audio samples. The number of samples per frame can be attained by calling"]
    #[doc = " 'pv_porcupine_frame_length()'. The incoming audio needs to have a sample rate equal to 'pv_sample_rate()' and be"]
    #[doc = " 16-bit linearly-encoded. Porcupine operates on single-channel audio."]
    #[doc = " @param[out] keyword_index Index of observed keyword at the end of the current frame. Indexing is 0-based and matches"]
    #[doc = " the ordering of keyword models provided to 'pv_porcupine_init()'. If no keyword is detected then it is set to -1."]
    #[doc = " @return Status code. Returns 'PV_STATUS_INVALID_ARGUMENT' or 'PV_STATUS_OUT_OF_MEMORY' on failure."]
    pub fn pv_porcupine_process(
        object: *mut pv_porcupine_t,
        pcm: *const i16,
        keyword_index: *mut i32,
    ) -> pv_status_t;
}
extern "C" {
    #[doc = " Getter for version."]
    #[doc = ""]
    #[doc = " @return Version."]
    pub fn pv_porcupine_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Getter for number of audio samples per frame."]
    #[doc = ""]
    #[doc = " @return Frame length."]
    pub fn pv_porcupine_frame_length() -> i32;
}
